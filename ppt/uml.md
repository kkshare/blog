title: UML简明参考
speaker: kk
url: https://kkshare.github.io
transition: slide3
theme: dark

[slide]

# 精简版UML

<small>2016-04-26 演讲者：何通庆</small>

[主页](https://kkshare.github.io)

[slide]
# 主要内容
## 关系
## 用例图
## 活动图
## 交互图
## 物理视图

[note]
需要思考的问题：
- 常用到的流程图是什么？
- 架构图又是什么？
- 各图之间的关系？
[/note]
[slide]
# 关系
----
- 包括：泛化关系、实现关系、依赖关系、关联关系
- *泛化关系*：对应java关键字extends
- *实现关系*：对应java关键字implements

*泛化关系*                      | *实现关系*
--------------------------------|------------------------------
![](../../images/umlextend.png) | ![](../../images/umlimpl.png)

[slide]
# 关系
*依赖关系*(或称*使用关系*)                   | *关联关系*
---------------------------------------------|--------------------------------------------------
单向                                         | 一般是平等的,单箭头表示单向，双箭头或无箭头表示双向
偶然性、临时性、非常弱的                     | 非临时的，非偶然的，强依赖关系
体现在局部变量，方法中的参数，静态方法的调用 | 成员变量或关联类A引用被关联类B的全局变量
![](../../images/umldepend.png)              | ![](../../images/umldepend2.png)
                                             | 每个端点有一个基数表示关联的类可以有几个实例

[slide]
# 关系--总结
- 如果被关联类B是关联类A的成员变量，而且是1:1的关系，B类比较简单的话，B类可以不用画出来 {:&.zoomIn}
- 聚合关系与组合关系都是关联关系的一种特例，本人不建议在实际项目的设计中使用
  * 抽象，增加学习难度，降低可读性（太学术） {:&.zoomIn}
  * 在代码层面与关联关系是一致的，只能从语义基本来区分（另一个角度来看就是逆向工程中不可逆）
  * 所谓模型就是对现实的简化，复杂的东西应该剪裁或少使用
  * 符合公司企业文化：简单

[slide]
# 关系--总结
- 本人觉得泛化关系与实现关系混用，或者只使用一个就行 {:&.zoomIn}
  * 线条过于抽象，增加学习成本 {:&.zoomIn}
  * 他们都能表示纵向关系
  * 具体环境(类图/代码)中好区分，或添加注释
- *纵向关系*：泛化关系、实现关系
- *横向关系*：依赖关系、关联关系
- 实际语言中“使用”一般表示依赖关系，“调用”一般表示关联关系
- 以上关系与图形在其他视图中都能够使用，表达相同或类似关系

[slide]
# 用例图
----
- 元素 {:&.zoomIn}
<div class="columns2">
    <img src="../../images/umlusercase.png">
    <div>
        参与者<br><br>
        用例<br><br>
        子系统
    </div>
</div>
- 用例图中关系  
![](../../images/umlusercase2.png)

[slide]
# 用例图
- 建议用关联关系与包含关系即可
- 例子  
![](../../images/umlusercase3.png)

[slide]
# 状态机视图
- 通过对类对象的生存周期建立模型来描述对象随时间变化的动态行为

[slide]
# 活动图 
----
- 活动图在本质上是一种流程图 {:&.zoomIn}
- 活动图着重表现从一个活动到另一个活动的控制流
- 活动图和交互图是UML中对系统动态方面建模的两种主要形式
- 交互图强调的是对象到对象的控制流
- 活动图则强调的是从活动到活动的控制流
- 活动图是一种表述过程基理、业务过程以及工作流的技术

[note]
- 参考 http://blog.csdn.net/zzxian/article/details/6781434
[/note]

[slide]
# 活动图
<div class="columns2">
    元素：分支、分岔、汇合
    <img src="../../images/umlflow.png">
</div>
- 示例  
![](../../images/umlflow2.png)

[slide]
# 活动图---如何绘制与绘制策略
- 首先决定是否采用泳道,以区别职责单位 {:&.zoomIn}
- 尽量使用分支、分岔和汇合等基本元素来描述活动控制流程
- 如果需要，加入对象流以及对象的状态变化（对重要对象）
- 关键是表示出控制流，其它元素都是围绕这一宗旨所进行的补充
- 一张图尽量只包含一个焦点
- 将复杂的活动或多次出现的活动集合归到一个活动节点
- 复杂活动通过辅助活动图或子活动图来表示
- 识别工作流初始节点的前置条件和活动终点的后置条件，可有效地确定工作流的边界
- 先从工作流的顺序开始，然后考虑分支，接着再考虑分岔和汇合
- 对操作建模：每一个对象占据一个泳道，而活动则是该对象的成员方法
- viso画图时用*用例图*中的*系统边界*代替*泳道*，容易编辑

[note]
- 是否采用泳道：主要根据活动图中是否要体现出活动的不同实施者(职责单位),该图能够有效地体现出所有职责单位之间的工作职责，业务范围及之间的交互关系、信息流程
- 一张图尽量只包含一个焦点:在一张图中显示出系统中所有的控制流是不可能的，除非系统很小
[/note]

[slide]

## 交互图
- 交互图分为*顺序图(序列图)*与*协作图(通讯图)* {:&.zoomIn}
- 顺序图与协作图可以相互转换。顺序图例子：  
![](../../images/umlactive.png)
- 对象下面元素：虚线-生命线，双实线-控制焦点，叉叉-生命结束
- 对象由“名字:类型”组成，一般可以省略名字。

[slide]
# 交互图
- *组合片段*:用来解决交互执行的条件及方式  
<img src="../../images/umlactive2.png" height="150">
- 常用组合片段
  * Opt     : 选项,包含一个可能发生或可能不发生的序列
  * Alt     : 抉择 
  * Loop    : 循环
  * Break   : 中断 
  * Par     : 并行 
  * Critical: 关键

[slide]
# 交互图
- 协作图(通讯图)例子  
![](../../images/umlcooperate.png)
- 协作图主要元素：
  * 消息编号
  * 迭代标记：用*号表示，表示循环，通常还有迭代表达式
  * 监护条件(约束)：通常是用来表示分支，格式是[Boolean Test]

[slide]
# 交互图总结
- 在通讯图中使用监护条件一定要有所限制 {:&.zoomIn}
- 通常应只列出主要监护条件，否则影响其阅读
- 如果需要，尽可能还是通过顺序图来表示
- 序列图与协作图一般情况画一种就行了
- 序列图是对象之间的关系，而不是类的关系，是动态图

[slide]
# 静态图与动态图
- 静态图：类图，对象图，构建图，部署图... {:&.zoomIn}
- 动态图：序列图，通讯图，用例图，状态机图...
- 逆向工程只能生成静态图，不能生成动态图
- 逆向工程无法生成表示聚合、组合关系的类图
- 动态图主要表现对象、示例、具体角色之间的关系、状态
- 静态图与动态图互为补充
- 用例图、序列图属于动态图
- 序列图是对象之间的关系，而不是类的关系，是动态图

[slide]
# 物理视图之组件视图
- 组件/构件：系统中可重用的块包装成具有可替代性的物理单元 {:&.zoomIn}
- 用组件以及组件之间的接口与依赖关系来表示设计元素的具体实现
- 组件是系统*高层*的可重用的组成部件
- 组件视图又称实现视图、构件视图
- 组件可以嵌套
<img src="../../images/umlcom.png" height="400">

[slide]
# 物理视图之部署视图
- 表示运行时计算资源的物理布置,这些运行的资源称为*节点* {:&.zoomIn}
- *节点*可以是打印机、服务器等有存储空间与处理能力的实体
- *节点*用长方体表示 
- 如果含有依赖关系的组件实例放置在不同节点上，可以展示执行过程中的瓶颈
- 单机程序不需要部署图

[slide]
# 物理视图之部署视图
- 部署视图分描述层与实例层
 * 描述层包括内部组件以及组件之间关系的表示  
![](../../images/umlcom2.png)  
我们可以增加{约束}来对连接及节点进行描述
 * 实例层只有简单的框图  
![](../../images/umlcom3.png)

[slide]
# 模型管理视图
- 大系统分成小单元，使得人们可以一次只处理有限的信息
- 使分别处理这些信息的工作组之间不会互相干扰
- 由包及包之间的依赖关系组成
- 很少用

[slide]
# 总结：UML图的种类
![](../../images/umltypes.png)

[slide]
# 补充：4+1视图模型#
- 参考 [这里](http://blog.csdn.net/sunchaohuang/article/details/1669390)
- Kruchten 提出了一个"4+1"视图模型，从5个不同的视角包括包括逻辑试图、进程视图、物理视图、开发视图、场景视图来描述软件体系结构。每一个视图只关心系统的一个侧面，5个视图结合在一起才能反映系统的软件体系结构的全部内容。

![](../../images/uml5views.png)

[slide]
# 补充：4+1视图模型
- 4+1视图与UML对应关系

4+1视图 | UML
--------|---
场景视图| 用例图
逻辑视图| 类图
开发视图| 类图、组件图
进程视图| 无完全对应
物理视图| 部署图

- *进程视图*：侧重系统的运行特性，关注非功能性的需求（性能，可用性）。服务于系统集成人员，方便后续性能测试。强调并发性、分布性、集成性、鲁棒性（容错）、可扩充性、吞吐量等。
[slide]
# 补充：4+1视图模型
- 相互关系
 * 将四个视图有机地联系起来。可以描述一个特定的视图内的构件关系，也可以描述不同视图间的构件关系。文本、图形表示皆可。 {:&.zoomIn}
 * 逻辑视图、开发视图，都主要是用来描述系统的静态结构。
 * 进程视图、物理视图，主要是用来描述系统的动态结构。
 * 并非每个系统都必须把5个视图都画出来，而是各有侧重。例如MIS系统侧重于逻辑视图、开发视图，而实时控制系统则侧重于进程视图、物理视图 

 * end of ppt,thanks!
