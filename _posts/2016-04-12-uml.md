---
layout: post
title: "uml"
description: "uml"
category: "tech"
tags: [uml,读书笔记]
tagline: "2016-04-15"

---
{% include JB/setup %}

## 关系: 泛化关系、实现关系、依赖关系、关联关系

*泛化关系*：对应java关键字extends

*实现关系*：对应java关键字implements

泛化:

![](/images/umlextend.png)

实现：

![](/images/umlimpl.png)

*依赖关系*：或者使用关系，单向。偶然性、临时性、非常弱的。体现在局部变量，方法中的参数，静态方法的调用

![](/images/umldepend.png)

*关联关系*：

- 非临时的，一般是长期性的，非偶然的，一般是平等的
- 强依赖关系
- 代码层面表现为：成员变量或关联类A引用被关联类B的全局变量
- 单箭头表示单向，双箭头或不带箭头表示双向
- 每个端点有一个基数表示关联的类可以有几个实例

![](/images/umldepend2.png)

如果被关联类B是关联类A的成员变量，而且是1:1的关系，B类比较简单的话，B类不用画出来也可以

聚合关系与组合关系都是关联关系的一种特例，我不建议在实际项目的设计中使用：

- 抽象，增加学习难度，降低可读性（太学术）
- 在代码层面与关联关系是一致的，只能从语义基本来区分（另一个角度来看就是逆向工程中不可逆）
- 符合公司企业文化：简单
- 所谓模型就是对现实的简化，复杂的东西应该剪裁或少使用

我觉得泛化关系与实现关系混用，或者只使用一个就行：

- 线条过于抽象，增加学习成本
- 他们都能表示纵向关系
- 实现类在具体环境中好区分，或者通过类图来区别（增加注释或约束）

*纵向关系*：泛化关系、实现关系 (作用：避免重复说明)

*横向关系*：依赖关系、关联关系

- 实际语言中“使用”一般表示依赖关系，“调用”一般表示关联关系
- 以上关系与图形在其他视图中都能够使用，表达相同或类似关系

## 用例图

*用例图元素*：参与者、用例、子系统

![](/images/umlusercase.png)

用例图中关系

![](/images/umlusercase2.png)

建议用关联关系与包含关机即可。例子

![](/images/umlusercase3.png)

*状态机视图*：通过对类对象的生存周期建立模型来描述对象随时间变化的动态行为

NOTE: **序列图**是对象之间的关系，而不是类的关系，是动态图

## 活动图 

参考 http://blog.csdn.net/zzxian/article/details/6781434

- 活动图在本质上是一种流程图。活动图着重表现从一个活动到另一个活动的控制流，是内部处理驱动的流程
- 活动图和交互图是UML中对系统动态方面建模的两种主要形式
- 交互图强调的是对象到对象的控制流，而活动图则强调的是从活动到活动的控制流
- 活动图是一种表述过程基理、业务过程以及工作流的技术。它可以用来对业务过程、工作流建模，也可以对用例实现甚至是程序实现来建模

分支、分叉、汇合

![](/images/umlflow.png)

示例

![](/images/umlflow2.png)

## 如何绘制活动图与策略

- 首先决定是否采用泳道：主要根据活动图中是否要体现出活动的不同实施者(职责单位),该图能够有效地体现出所有职责单位之间的工作职责，业务范围及之间的交互关系、信息流程
- 然后尽量使用分支、分岔和汇合等基本的建模元素来描述活动控制流程
- 如果需要，加入对象流以及对象的状态变化（只对重要对象）
- 活动图的建模关键是表示出控制流，其它的建模元素都是围绕这一宗旨所进行的补充
- 一张图尽量只包含一个焦点(除非系统很小，否则不可能在一张图中显示出系统中所有的控制流),将复杂的活动或多次出现的活动集合归到一个活动节点，并通过辅助活动图或子活动图来表示它们
- 识别工作流初始节点的前置条件和活动终点的后置条件，可有效地实现对工作流的边界进行建模。
- 找出连接这些活动节点的转换，首先从工作流的顺序开始，然后考虑分支，接着再考虑分岔和汇合
- 对操作建模：每一个对象占据一个泳道，而活动则是该对象的成员方法

思考：

- 逆向工程只能生成静态图，不能生成动态图
- 无法生产表示聚合、组合关系的类图
- 动态图主要表现对象、示例、具体角色之间的关系、状态
- 静态图与动态图互为补充

NOTE: 用例图、序列图属于动态图

## 交互图

交互图分为**顺序图(序列图)**与**协作图(通讯图)**

顺序图与协作图可以相互转换，例子：

![](/images/umlactive.png)

*对象下面元素*：虚线-生命线，双实线-控制焦点，叉叉-生命结束

对象由“名字:类型”组成，一般可以省略名字。

*组合片段*:用来解决交互执行的条件及方式

![](/images/umlactive2.png)

常用组合片段

    片段类型	名称	说明
    Opt	选项	包含一个可能发生或可能不发生的序列。 可以在临界中指定序列发生的条件。
    Alt	抉择	
    Loop    循环	
    Break	中断	
    Par	并行	
    Critical	关键	

*协作图(通讯图)*

![](/images/umlcooperate.png)

协作图主要元素：

- 消息编号
- 迭代标记：用*号表示，表示循环，通常还有迭代表达式，用来说明循环规则
- 监护条件(约束)：通常是用来表示分支的，也就是表示“如果条件为true，才发送消息”，格式是[Boolean Test]

NOTE: 在通信图中使用监护条件一定要有所限制，通常应只列出主要的监护条件，否则会影响其阅读。如果需要，尽可能还是通过顺序图来表示

顺序图与协作图一般情况画一种就行了。

## 物理视图

部署图用来帮助读者了解软件中的各个组件驻留在什么硬件位置，以及这些硬件之间的交互关系。

目的：可重用性、可操作性表示实现单元

两种视图：组件视图与部署视图

## 组件视图

又称实现视图、构件视图

组件可以嵌套

![](/images/umlcom.png)

## 部署视图

如果含有依赖关系的组件实例放置在不同节点上，部署图可以展示执行过程中的瓶颈

*节点*：是运行时存在的物理元素，它表示了一种可计算的资源，通常至少有存储空间和处理能力  
它可以用来描述实际的PC机、打印机、服务器等软件运行的基础硬件  
UML图中用长方体表示  
出现在物理视图中  

单机程序不需要部署图

部署视图分描述层与实例层
描述层包括内部构件以及构件之间关系的表示
实例层只有简单的框图

![](/images/umlcom2.png)

我们可以增加{约束}来对连接及节点进行描述

实例层部署图：

![](/images/umlcom3.png)


## 模型管理视图

- 大系统分成小单元，使得人们可以一次只处理有限的信息，并且分别处理这些信息的工作组之间不会互相干扰
- 由包及包之间的依赖关系组成

## UML图的种类
![](/images/umltypes.png)

## 4+1视图模型#

参考 [这里](http://blog.csdn.net/sunchaohuang/article/details/1669390)

Kruchten 提出了一个"4+1"视图模型，从5个不同的视角包括包括逻辑试图、进程视图、物理视图、开发视图、场景视图来描述软件体系结构。每一个视图只关心系统的一个侧面，5个视图结合在一起才能反映系统的软件体系结构的全部内容。

![](/images/uml5views.png)

4+1视图与UML对应关系

    4+1视图          UML
    场景视图          用例图
    逻辑视图          类图
    开发视图          类图、组件图
    进程视图          无完全对应
    物理视图          部署图

*进程视图*：侧重系统的运行特性，关注非功能性的需求（性能，可用性）。服务于系统集成人员，方便后续性能测试。  
强调并发性、分布性、集成性、鲁棒性（容错）、可扩充性、吞吐量等。
    
相互关系：

- 将四个视图有机地联系起来。可以描述一个特定的视图内的构件关系，也可以描述不同视图间的构件关系。文本、图形表示皆可。
- 逻辑视图、开发视图，都主要是用来描述系统的静态结构。
- 进程视图、物理视图，主要是用来描述系统的动态结构。
- 并非每个系统都必须把5个视图都画出来，而是各有侧重。例如MIS系统侧重于逻辑视图、开发视图，而实时控制系统则侧重于进程视图、物理视图 

## visio画图心得

- 画活动图时用用例图中的系统边界代替泳道，容易编辑

