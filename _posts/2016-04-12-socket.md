---
layout: post
title: "socket"
description: ""
category: "tech"
tags: [socket,tcp-ip]
tagline: "2016-04-15"

---
{% include JB/setup %}

## setsockopt 参数设置

    SO_REUSEADDR：     closesocket/close后重用TIME_WAIT socket：
    SO_DONTLINGER          如果要已经处于连接状态的soket在调用closesocket后强制关闭，不经历TIME_WAIT的过程：
    SO_SNDTIMEO/SO_RCVTIMEO：     在send(),recv()过程中有时由于网络状况等原因，发收不能预期进行,而设置收发时限：
    SO_RCVBUF/SO_SNDBUF：         
     接收/发送缓冲区在send()的时候，返回的是实际发送出去的字节(同步)或发送到socket缓冲区的字节(异步);     系统默认的状态发送和接收一次为8688字节(约为8.5K)；在实际的过程中发送数据和接收数据量比较大， 可以设置socket缓冲区，而避免了send(),recv()不断的循环收发：
     如果在发送数据的时，希望不经历由系统缓冲区到socket缓冲区的拷贝而影响程序的性能，可设置发送缓冲区为0
     如果在recv()完成是设置接收缓冲区为0，避免socket缓冲区的内容拷贝到系统缓冲区
    SO_BROADCAST：     一般在发送UDP数据报的时候，希望该socket发送的数据具有广播特性：
    SO_CONDITIONAL_ACCEPT:
     在client连接服务器过程中，如果处于非阻塞模式下的socket在connect()的过程中可以设置connect()延时, 直到accpet()被呼叫(本函数设置只有在非阻塞的过程中有显著的作用，在阻塞的函数调用中作用不大)
    SO_LINGER:      在closesocket()调用,但是还有数据没发送完毕的时候容许逗留
    close和shutdown区别
     close-关闭本进程的sfd，但链接还是开着的，用这个sfd的其它进程还能用这个链接，能读或写这个sfd，     它只是减少sfd的引用计数，并不直接关闭连接，只有当sfd的引用计为0时才关闭连接。
     shutdown-破坏了socket链接，读的时候可能侦探到EOF结束符，写的时候可能会收到一个SIGPIPE信号，这个信号可能直到socket buffer被填充了才收到。关闭方式的参数：0不能再读，1不能再写，2 读写都不能。该函数允许你只停止在某个方向上的数据传输
     可直接关闭sfd，不考虑sfd的引用计数，可选择中止一个方向的连接。
          1. 若多进程共享一套接字，close每被调用一次，计数减1，直到计数为0时，也就是所用进程都调用了close，套接字将被释放。
          2. 一个进程中shutdown(sfd, SHUT_RDWR)后其它的进程将无法进行通信. 如果一个进程close(sfd)将不会影响到其它进程.
    TCP_NODELAY:不使用Nagle算法--不组包到一定长度再发，直接发送
    O_NDELAY/O_NONBLOCK:都是设置文件成非阻塞方式 1. Linux中O_NDELAY被宏定义成O_NONBLOCK 2.读取空pipe和文件结尾是返回值与错误代码不同
    select epoll 对比：
     select:轮询方式；Linux下处理fd数有限制，windows没有；过程：
          应用层初始化,FD_SET(填入需要检测的socket集合)-->内核用对FD_SET逐个检查-拷贝到内部数据-拷贝到FD_SET-->返回应用-->
          检查数组，处理“上下文映射”（使用map/hash_map），后续处理
     缺点：1.初始化需要填入数组 2.内核需要拷贝数组，数据较多 3.需要上下文映射 4.不管有没有事件发生都要检测每个socket(内核态、应用态)
     epoll:触发方式；处理fd数无限制，但需要调用API重新设置资源限制；过程：
          epoll_wait检测事件发生的连接-->内核对epoll_ctl注册事件的socket进行跟踪，有事件发生的socket保存到内部数组;
          当接到epoll_wait调用时，将该集合直接拷贝到epoll_event数组，返回给应用-->根据epoll_event中的“自定义变量”进行上下文映射

## tcp

                     client        server
                       |              |listen
       主动打开SYN_SEND|-----SYNj---->|SYN_RECV
            ESTABLISHED|<-SYNk,ACKj+1-|
                       |---ACKk+1---->|ESTABLISHED
                       /              /
                       |              |
                close()|              |
     主动关闭FIN_WAIT_1|----FINm----->|CLOSE_WAIT(被动关闭)
             FIN_WAIT_2|<---ACKm+1----|
                       |              |close()
                       |<---FINn------|LAST_ACK
              TIME_WAIT|----ACKn+1--->|CLOSED

- 出现FIN_WAIT_2/CLOSE_WAIT说明有异常，FIN_WAIT_2没有设置超时,CLOSE_WAIT默认维持7200秒，通过命令修改：
    sysctl -w net.ipv4.tcp_keepalive_time=30
    sysctl -w net.ipv4.tcp_keepalive_probes=2
    sysctl -w net.ipv4.tcp_keepalive_intvl=2
- 出现TIME_WAIT属正常，过一定时间会消失，TIME_WAIT坚持一段时间保证了ACK有足够的时间到达服务器，超时了会重发，直到服务器收到
- 主动关闭的一方发生完FIN之后不能再发送数据，但还可能接收数据。
- CLOSE_WAIT仍然能发送数据，但不能接收数据，执行close之后才最终关闭。
- 经验：当被动关闭的一方recv时返回SOCKET_ERROR,此时需要调用closesocket()
- close()含义：我没有数据发送给你了

## 异步 同步 阻塞 非阻塞 多路复用

### 阻塞和非阻塞

    数据未准备好时是否立即返回（无数据可读、无缓冲可写）
    在阻塞模式下, 如send函数将数据拷贝到发送缓存中发送并得到确认后再返回.(接收端只要将数据收到接收缓存中,就会确认,并不一定要等待应用程序调用recv)
    在非阻塞模式下,send函数的过程仅仅是将数据拷贝到协议栈的缓存区而已
    非阻塞I/O一般只针对网络I/O有效,我们只要在socket的选项设置中使用 O_NONBLOCK 即可(有的系统用 FNEDLAY 、 O_NDELAY)
    读(read/recv/msgrcv):具体的接收数据不是由这些调用来进行,是由于系统底层自动完成的。read、recv等只负责把数据从底层缓冲copy 到我们指定的位置
    阻塞读: 有多少读多少，没有数据就会一直等待。(如果读到的数据量比参数中指定的长度要小，read 并不会一直等待下去，而是立刻返回)
    非阻塞读：有多少读多少，没有数据立即返回
         没错，阻塞与非阻塞读都是有多少读多少，区别是没有数据时候是否立即返回
    阻塞写(send/write/msgsnd)：会一直等待，直到write 完，全部的数据再返回(不过可能被中断)
    非阻塞写：可以写多少就写多少（有本地发送缓冲可用大小决定）
    对于一个socket 是阻塞模式还是非阻塞模式有两种方式来处理:
    方法1、fcntl 设置
    方法2、recv,send 系列的参数。(临时设置，无论原有是阻塞还是非阻塞)

### 同步和异步

是指*访问数据*的机制,同步一般指主动请求并等待I/O操作(包括数据复制)完毕的方式,当数据就绪后在读写的时候必须阻塞(区别就绪与读写二个阶段,同步的读写必须阻塞),异步则指主动请求数据后便可以继续处理其它任务,随后等待I/O,操作完毕的通知,这可以使进程在数据读写时也不阻塞。(等待"通知")
即数据复制是应用程序完成还是操作系统完成，前者是同步，后者是异步

#### 同步阻塞

等待I/O操作完成再继续运行，简单而有效的I/O模型,它可以和多进程结合起来有效的利用CPU资源,但是代价就是多进程的大量内存开销

#### 同步非阻塞

类似while(true){if... if... }，好处是一个进程处理多个IO请求，劣势是需要不停的轮询。  
如 lighttpd,libevent,ACE,Twisted,java nio,reactor(同步+非阻塞+IO多路复用)

#### 异步阻塞

java aio, 此时用户进程只需要对数据进行处理就好了，不需要进行实际的IO读写操作,但要为每个操作启动一个线程  
异步非阻塞例子：IO复用/信号驱动式IO，proactor

jvm的NIO使用的是linux 系统调用epoll模型  
reactor (同步IO-):    事件分离器--------------(IO准备就绪)-->事件处理器(非抢占-可能发生优先级逆转-无法保证时延)  
proactor(采用异步IO)：事件分离器(兼任处理器)--(IO操作完成)-->IO操作完成事件IO操作本身由操作系统来完成，  
典型的异步模式实现，建立在操作系统支持异步API的基础之上，我们将这种实现称为“系统级”异步或“真”异步，
因为应用程序完全依赖操作系统执行真正的IO工作,Proactor中，应用程序需要传递缓存区  
两种pool: task pool, thread pool

#### I/O多路复用(I/O multiplexing)-select epoll

    ACE称同步事件多路分离
    1.强调多路. 2.只针对请求数据是否就绪.不针对i/o读写
    它既解决了Blocking I/O数据处理不及时，又解决了Non-Blocking I/O采用轮旬的CPU浪费问题，同时它与异步I/O不同的是它得到了各大平台的广泛支持
    与多线程和多进程相比，I/O多路复用的最大优势是系统开销小，系统不需要建立新的进程或者线程，也不必维护这些线程和进程
    select, epoll都只需要进程被动接收到数据就绪"通知".符合异步的定义. 不需要一直在饭馆等(同步阻塞).或轮询(同步非阻塞).
    多路I/O就绪通知的出现,提供了对大量文件描述符就绪检查的高性能方案,它允许进程通过一种方法来同时监视所有文件描述符,并可以快速获得所有就绪的文件描述符,然后只针对这些文件描述符进行数据访问。

    select在异步connect中的应用,大致过程:
    1.socket设为非阻塞：fcntl(socket, F_SETFL, O_NDELAY)
    2.调用connect,这时返回-1,但是errno被设为EINPROGRESS,意即connect仍旧在进行还没有完成.
    3.将打开的socket设进被监视的可写(注意不是可读)文件集合用select进行监视,如果可写,用
            getsockopt(socket, SOL_SOCKET, SO_ERROR, &error, sizeof(int));
    来得到error的值,如果为零,则connect成功.

NOTE:阻塞的socket应该先知道socket句柄的可读写性，再发起动作。因为如果直接发起操作，由于阻塞的特性，它比非阻塞占用了更多的CPU时间。 当有东西可读时，一定要检查recv()或read()的返回值，返回-1时要作出关断本地Socket的处理，否则select()会一直认为有东西读， 其结果曾几令cpu伤心欲断针脚。

![](/images/syncBlockIOModel.png)
  
*同步阻塞 I/O 模型的典型流程*  
在调用 read 系统调用时，应用程序会阻塞并对内核进行上下文切换。然后会触发读操作，当响应返回时（从我们正 在从中读取的设备中返回），数据就被移动到用户空间的缓冲区中。然后应用程序就会解除阻塞（read 调用返回）
从应用程序的角度来说，read 调用会延续很长时间。实际上，在内核执行读操作和其他工作时，应用程序的确会被阻塞。  
PS. 我理解这里的意思是，read请求是阻塞的，也没有异步通知机制，因为应用程序一直在这个过程中等待，即一直在主动查询，所以是同步的。（顺序）

![](/images/syncUnblockIOModel.png)

*同步非阻塞 I/O 模型的典型流程*  
非阻塞的实现是 I/O 命令可能并不会立即满足，需要应用程序调用许多次来等待操作完成。这可能效率不高，因为在很多情况下，当内核执行这个命令时，应用程序必须要进行忙碌等待，直到数据可用为止，或者试图执行其他工作。正如图 3 所示的一样，这个方法可以引入 I/O 操作的延时，因为数据在内核中变为可用到用户调用 read 返回数据之间存在一定的间隔，这会导致整体数据吞吐量的降低。  
PS. 我理解这里的意思是，read请求是非阻塞的，但是这里没有异步通知机制，而需要应用程序主动查询，所以是同步的。（多次试探）

![](/images/asyncBlockIOModel.png)

*异步阻塞 I/O 模型的典型流程 (select)*  
在这种模型中，配置的是非阻塞 I/O，然后使用阻塞 select 系统调用来确定一个 I/O 描述符何时有操作。使 select 调用非常有趣的是它可以用来为多个描述符提供通知，而不仅仅为一个描述符提供通知。对于每个提示符来说，我们可以请求这个描述符可以写数据、有读数据可用 以及是否发生错误的通知。
select 调用的主要问题是它的效率不是非常高。尽管这是异步通知使用的一种方便模型，但是对于高性能的 I/O 操作来说不建议使用。  
PS. 我理解这里的意思是，read请求实际上是非阻塞的，但是在异步通知方式上，采用了阻塞的slect系统调用，导致应用程序被阻塞，所以虽然异步，但任然阻塞。（等待通知，自己完成）

![](/images/asyncUnblockIOModel.png)

*异步非阻塞 I/O 模型的典型流程*  
读请求会立即返回，说明 read 请求已经成功发起了。在后台完成读 操作时，应用程序然后会执行其他处理操作。当 read 的响应到达时，就会产生一个信号或执 行一个基于线程的回调函数来完成这次 I/O 处理过程。
在一个进程中为了执行多个 I/O 请求而对计算操作和 I/O 处理进行重叠处理的能力利用了处理速度与 I/O 速度之间的差异。当一个或多个 I/O 请求挂起时，CPU 可以执行其他任务；或者更为常见的是，在发起其他 I/O 的同时对已经完成的 I/O 进行操作。

PS. 我理解这里的意思是，read请求实际上是非阻塞的，但是在异步通知方式上，采用了回调函数，无需应用程序再去处理。（委托完成）

*异步 I/O 的动机*  
从前面 I/O 模型的分类中，我们可以看出 AIO 的动机。阻塞模型要求在 I/O 操作开始时阻塞应用程序，这意味着不可能同时重叠进行处理和 I/O 操作。同步非阻塞模型允许处理和 I/O 操作重叠进行，但是这需要应用程序根据重现的规则来检查 I/O 操作的状态。这样就剩下异步非阻塞 I/O 了，它允许处理和 I/O 操作重叠进行，包括 I/O 操作完成的通知。

这里我要特别强调一下异步IO和非阻塞IO的区别，异步IO就是把IO提交给系统，让系统替你做，做完了再 用某种方式通知你；非阻塞IO就是你要通过某种方式不定时地向系统询问你是否可以开始做某个IO，当可以开始后，还是要自己来完成IO

